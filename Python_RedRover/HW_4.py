line_0 = "-----------------"
line = line_0 * 9
print(line)

# 4.1. Напишите функцию square, принимающую 1 аргумент — сторону квадрата, и возвращающую 3 значения (с помощью кортежа):
#      периметр квадрата, площадь квадрата и диагональ квадрата.
print("4.1. Напишите функцию square, принимающую 1 аргумент — сторону квадрата, и возвращающую 3 значения (с помощью кортежа):\n"
      "     периметр квадрата, площадь квадрата и диагональ квадрата.\n")
a = 5
print('площадь квадрата =', a * a)
print('периметр квадрата =', a * 4)
print('диагональ квадрата =', round(a * (2 ** 0.5)))
print()
print(line)

# 4.2. Напишите фукнцию, которая принимает произвольное количество именнованных аргументов и выводит их построчно
#      в формате аргумент: значение. Например:
# 	name: John
# 	last_name: Smith
# 	age: 35
# 	position: web developer

print('4.2. Напишите фукнцию, которая принимает произвольное количество именнованных аргументов и выводит их построчно \n'
      '     в формате аргумент: значение. Например:\n'
      '	name: John\n'
      '	last_name: Smith\n'
      '	age: 35 \n'
      '	position: web developer\n')
my_dict = {
      'name':       'John',
	  'last_name':  'Smith',
	  'age':        35,
	  'position':   'web developer'
}
print(my_dict)
def key_value(**kwargs):
    print(*kwargs.items(), sep='\n')

key_value(name='Johnn', last_name='Smith', age=35 )
print()
print(line)

# 4.3. Используя лямбда-выражение, из списка my_list = [20, -3, 15, 2, -1, -21] создайте новый список, содержащий только
#      положительные числа
print("4.3. Используя лямбда-выражение, из списка my_list = [20, -3, 15, 2, -1, -21] создайте новый список, содержащий только "
      "положительные числа")
my_list = [20, -3, 15, 2, -1, -21]

new_list = list(filter(lambda x: x > 0, my_list))
print(new_list)
print()
print(line)

# 4.4. Используя лямбда выражение, получите результат перемножения значений в предыдущем списке
print("4.4. Используя лямбда выражение, получите результат перемножения значений в предыдущем списке \n")
from functools import reduce

res = reduce(lambda x, y: x*y, my_list)
print(res)
print()
print(line)

# 4.5. Напишите декоратор, который высчитывает время работы функции, которую он принимает в качестве параметра
print("4.5. Напишите декоратор, который высчитывает время работы функции, которую он принимает в качестве параметра")

import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Время выполнения функции '{func.__name__}': {execution_time:.4f} секунд")
        return result
    return wrapper

# Пример использования декоратора
@timing_decorator
def some_function():
    # Здесь может быть какой-то код
    time.sleep(2)  # Имитация работы функции в течение 2 секунд

some_function()
print()
print(line)

# 4.6. Создайте файл my_calc.py и пропишите в нем минимум 4 функции, выполняющие базовые арифметические вычисления.
#      Примените эти функции в качестве методов в другом файле.
print("4.6. Создайте файл my_calc.py и пропишите в нем минимум 4 функции, выполняющие базовые арифметические вычисления.\n"
      "Примените эти функции в качестве методов в другом файле. \n")

def sum(a, b):
    return a + b

def minus(a, b):
    return a - b

def div(a, b):
    return a / b

def stepen(a, b):
    return a ** b